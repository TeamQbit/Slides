---
transition: none
width: "900"
timeForPresentation: "0"
---
მონაცემთა სტრუქტურები
---
რა არის მონაცემთა სტრუქტურები?
note:
	მონაცემთა სტრუქტურები არის მონაცემთა ორგანიზების და შენახვის გზა რათა ის ეფექტურად იყოს გამოყენებული.მაგალითად როგორც წიგნებისთვის თაროა შენახვის და ოგრანიზების ყველაზე ეფექტური გზა,ტანსაცემელისთვის კარადა ან საჭმლისთვის მაცივარი, ასევე კომპიუეტი იყენებს სხვადასხვა მონაცემთა სტრუქტურას.დღეს ჩვენ რამდენიმე მათგანზე მოგიყვებით
	
---

![[Pasted image 20250412211448.png|600]]

---
![[Pasted image 20250412211604.png|600]]
---

 მასივი(array)
note:
როგორც უკვე ვასენეთ მასივი არის მონაცემთა სტრუქტურა რომელიც ინახავს ერთი ტიპის რამდენიმე მონაცემს,ერთ ცვლადში ნაცვლად ბევრი ცვლადისა,მაგრამ მასივს აქვს ერთი ნაკლი.მისი ზომის შეცვლა არ შეიძლება.ამ პრობლემის მოსაგვარებლად გვაქვს  დინამიური მასივი.

---
![[Pasted image 20250412104510.png]]

---
<img src="Images/Pasted image 20250412105401.png"  >

---
დინამიური მასივი(ArrayList)
 note:
	 ერეილისტის ძირითადი მუშაობის პრინციპი იგივეა როგორიც მასივის,ისიც ინდექსირებული მონაცემთა სტრუქტურაა.მაგრამ  მას შეუძლია ნებისმიერი ელემენტის ამოშლა ან ნებისმიერ ინდექსზე ჩამატებას.

---
როგორ მუშაობს ერეილისტი?
note:
	ის ჩვეულებრივ მასივს იყენებს მონაცემთა შესანახად,მაგრამ როდესაც მოცემული მასივი შეივსება არსებულ მასივს გადააკოპირებს და ორჯერ დიდ მასივში ჩაწერს,ხოლო როდესაც არსებული ელემენტების რაოდენობა მასივის მესამედს გაუტოლდება არსებულ ელემენტებს ორჯერ პატარა მასივში ჩაწერს 


---
<!-- slide: style="font-size: 0.6em" -->

| მეთოდი            | აღწერა                                  |
| ----------------- | --------------------------------------- |
| `add(E e)`        | ამატებს ელემენტს ბოლოში                 |
| `add(int i, E e)` | ამატებს ელემენტს მოცემულ ინდექსზე       |
| `get(int index)`  | იღებს ელემენტს მოცემული ინდექსიდან      |
| `size()`          | აბრუნებს ელემენტების რაოდენობას (ზომას) |
| remove(int index) | შლის ელემენტს მოცემული ინდექისდან       |
| clear()           | შლის ყველა ელემენტს                     |


---


 სიმრავლე(set)
 
note:
	 როგორც მათემატიკიდან ვიცით სიმრავლე არის რამდენიმე ელემენტის ერთობა,ოღონდ იმ პირობით რომ თითოეული ელემენტი მხოლოდ ერთხელ გვხვდება მოცემულ სიმრავლეში,განსხვავებით მასივისგან სიმრავლე დაუნომრავი მონაცემთა სტრუქტურაა შესაბამიდად მას არ გააჩნია ინდექსები
	 

---
$\{1,2,3....100,300\}$
$\{მათე, რეზი, დემეტრე, \ldots, ქუბიტი\}$


---

![[Pasted image 20250412213911.png]]

---
<!-- slide: style="font-size: 0.49em" -->

| მეთოდი                  | აღწერა           |
|--------------------------|---------------------------
| `add(E e)`               | ამატებს ელემენტს (თუ უკვე არ არსებობს) |                    
| `addAll(Collection c)`   | ამატებს ყველა ელემენტს სხვა კოლექციიდან  |
| `remove(Object o)`       | შლის კონკრეტულ ელემენტს|                                  
| `clear()`                | შლის ყველა ელემენტს                                           |
| `contains(Object o)`     | ამოწმებს, შეიცავს თუ არა სიმრავლე მოცემულ ელემენტს |
| `isEmpty()`              | ამოწმებს, ცარიელია თუ არა სიმრავლე                                       |
| `size()`                 | აბრუნებს სიმრავლის ზომას     |



---
მეფი(map) ან ზოგ ენაში ლექსიკონი(dictionary)
note:
	მეფი(map) ან ზოგ ენაში ლექსიკონი(dictionary)
	მეფი არის მონაცემთა სტრუქტურა რომელიც ინახავს გასაღები(key)-მნიშვნელობა(value) წყვილებს.ეს ნიშნავს რომ ყოველი მნიშვნელობა დაკავშირებულია რაღაც ტიპის უნიკალურ გასაღებთან რაც მის ძებნას უფრო ამარტივებს.
	 მაგალითად:
	წარმოიდგინეთ ტელეფონის წიგნი სადაც სახელები არის გასაღებები (Keys) ტელეფონის ნომრები არის მნიშვნელობები (Values).
	როდესაც გსურთ ვინმეს ტელეფონის ნომრის პოვნა, არ კითხულობთ მთელ წიგნს, არამედ უბრალოდ პოულობთ სახელს (გასაღებს) და იღებთ ნომერს (მნიშვნელობას)

---


| car  | $\longrightarrow$  მანქანა             |
| ---- | -------------------------------------- |
| door | $\longrightarrow$ კარი                 |
| Qbit | $\longrightarrow$ საუკეთესო იუთუბ არხი |

 
---
<!-- slide: style="font-size: 0.49em" -->

| მეთოდი                        | აღწერა                                               |
| ----------------------------- | ---------------------------------------------------- |
| `put(K key, V value)`         | ამატებს გასაღებ-მნიშვნელობის წყვილს მაპში            |
| `get(Object key)`             | აბრუნებს მნიშვნელობას მითითებული გასაღებისთვის       |
| `remove(Object key)`          | შლის გასაღებსა და მის მნიშვნელობას                   |
| `containsKey(Object key)`     | ამოწმებს, შეიცავს თუ არა მეფი მითითებულ გასაღებს     |
| `containsValue(Object value)` | ამოწმებს, შეიცავს თუ არა მეფი მითითებულ მნიშვნელობას |
| `size()`                      | აბრუნებს მეფის ზომას                                 |
| `isEmpty()`                   | ამოწმებს, ცარიელია თუ არა მეფი                       |
| `clear()`                     | შლის ყველა წყვილს მეფიდან                            |

---
სტეკი(stack)
note:
	სტეკი(stack)
	სტეკი არის მონაცემთა სტრუქტურა რომელიც მიყვება ბოლო შევიდა პირველი გამოვიდა(Last In, First Out (LIFO)) პრინციპს, რაც იმას ნიშნავს რომ ბოლო ელემენტი რომელიც დაემატება სტეკში პირველი იქნება რომელიც ამოიშლება.
	მაგალიღად:
	წარმოიდგნეთ გვაქვს ერთმანეთზე დაწყობილი თეფშები.ჩვენ ახალი თეფში აუცილებლად თავზეო უნდა დავადოთ ამ გროვას და არ შეგვიძლია პირველი თეფში ავიღოთ იქამდე სანამ ყველა მის შემდეგ დამატებულ ღეფშს არ ავიღებთ.

---
![[Pasted image 20250411203536.png]]
---

![[Pasted image 20250411213332.png|800]]




---
<!-- slide: style="font-size: 0.55em" -->

| მეთოდი         | აღწერა                                              |
| -------------- | --------------------------------------------------- |
| `push(E item)` | ელემენტის დამატება სტეკში                           |
| `pop()`        | სტეკის ზევითა ელემენტის ამოღება და დაბრუნება        |
| `peek()`       | სტეკის ზევითა ელემენტის დაბრუნება (ამოღების გარეშე) |
| `empty()`      | ამოწმებს არის თუ არა სტეკი ცარიელი                  |
| `size()`       | აბრუნებს სტეკის ზომას                               |

---

რიგი(queue)
note:
	რიგი არის მონაცემთა სტრუქტურა პრომელიც მიყვება პირველი შევიდა პირველი გამოვიდა(First In, First Out (FIFO)) პრინციპს,რაც იმას ნიშნავს რომ პირველი ელემენტი რომელიც დაემატა იქნება პირველი რომელიც ამოიშლება,როგორც ცოცხალი რიგის შემთხვევაში.იმას უფრო ადრე მოუწევს რიგი ვინც უფრო ადრე მივიდა

---

![[Pasted image 20250411212803.png]]

---
<!-- slide: style="font-size: 0.6em" -->

| მეთოდი       | აღწერა                                                                              |
| ------------ | ----------------------------------------------------------------------------------- |
| `offer(E e)` | ელემენტის დამატება რიგში                                                            |
| `poll()`     | რიგის თავში მყოფი ელემენტის ამოღება და დაბრუნება (აბრუნებს null-ს თუ რიგი ცარიელია) |
| `peek()`     | რიგის თავში მყოფი ელემენტის დაბრუნება (ამოღების გარეშე)                             |
| `size()`     | აბრუნებს რიგის ზომას                                                                |
| `empty()`    | ამოწმებს არის თუ არა რიგი ცარიელი                                                   |

---

ბმული სია(linked list)
note:
	ბმული სია  არის მონაცემთა მიმდევრობითი სტრუქტურა, რომლის ყოველი ელემენტი ინახავს ორი ტიპის ინფორმაციას:ამ ელემენტის მნიშვნელობას და მომდევნო ელემენტის მისამართს.
	არსებობს 2 ტიპის ბმულის სია
	1)ცალმხირვ მიმართული ბმული სიები - მხოლოდ მომდევნო ელემენტის მისამართზე და საკუთარ მნიშვნელობაზე აქვს ინფორმაცია
	2)ორ მხრივ მიმართული ბმული სიები - აქვს ინფორმაცია მის მომდევნო და წინა ელემენტის მისამართზე ასევე საკუთარ მნიშვნელობაზე

---
![[Pasted image 20250411203639.png]]

---
![[Pasted image 20250411203733.png]]

---
![[Pasted image 20250411203906.png]]

---
![[Pasted image 20250411205844.png]]

---
![[Pasted image 20250411204103.png]]

---
![[Pasted image 20250411204142.png]]

---
![[Pasted image 20250411204228.png]]

---
გრაფი(graph)
note:
	გრაფი არის მონაცემთა სტრუქტურა რომელიც შედგება წვეროებისა და წიბოების სიმარავლეებისგან.გრაფები გამოიყენება კავშირების ან ურთიერთობების წარმოსადგენად ობიექტებს შორის.
	არსებობს რამდენიმე ტიპის გრაფი
	1)მიუმართავი გრაფი (Undirected Graph) – მიუმართავ გრაფში წიბოებს (Edges) არ აქვთ მიმართულება, რაც ნიშნავს, რომ ურთიერთობა ორივე მხარეს მოქმედებს.
	2)მიმართული გრაფი (Directed Graph, Digraph) – მიმართულ გრაფში წიბოები (Edges) გარკვეულ მიმართულებას მიჰყვებიან. თითოეული კავშირი ერთი წვეროდან (Node) მეორეზე მიუთითებს.
	მაგალითი: სოციალური ქსელი, სადაც მომხმარებელი სხვა მომხმარებელი ყავს გამოწერილი 
	მაგალითი: სოციალური ქსელი, სადაც ორი ადამიანი ერთმანეთის მეგობარია.
	3)აწონილი გრაფი (Weighted Graph) – გრაფში თითოეულ კავშირს აქვს გარკვეული წონა (Weight) ან ღირებულება (Cost). ეს სასარგებლოა, როდესაც კავშირებს კონკრეტული მნიშვნელობა აქვს, მაგალითად, მანძილი ან ღირებულება.
	მაგალითი: საგზაო რუკა, სადაც წონა წარმოადგენს ქალაქებს შორის მანძილს.	
	4)ციკლური გრაფი (Cyclic Graph) – გრაფი, რომელიც შეიცავს მინიმუმ ერთ ციკლს, ანუ გზას, რომელიც ერთსა და იმავე წვეროზე იწყება და მთავრდება. 

---
![[Pasted image 20250411204513.png]]

---

![[Pasted image 20250411204600.png]]

---
![[Pasted image 20250412102724.png|800|500]]


---



![[Pasted image 20250411204822.png]]
---
![[Pasted image 20250411205040.png]]
---
ხე(tree)
note:
	ხე არის იერარქიული მონაცემთა სტრუქტურა, რომელიც შედგება წვეროებისგან (Nodes), რომლებიც ერთმანეთთან წიბოებით (Edges) არიან დაკავშირებული.
	გრაფებისგან განსხვავებით, ხეებს აქვთ გარკვეული წესები:
	 ხეს აქვს ერთიანი საწყისი წვერო (Root Node).
	 თითოეულ წვეროს (გარდა ფესვისა) ყავს მხოლოდ ერთი მშობელი (Parent Node).
	 ხე არ შეიცავს ციკლებს .
	 ხის ტიპები
	 1)ორობითი ხე(binary tree)- ხე, სადაც თითოეულ წვეროს შეიძლება ჰყავდეს არაუმეტეს ორი შვილობილი წვერო (მარცხენა და მარჯვენა). მისი ქვესახეობაა ორობითი ძებნის ხე.ორობით ბეძნის ხისგან განსხვავებით დამატებული აქვს ერთი პირობა რომ მარცხენა შვილობილი წვერო ნაკლებია მშობელზე და მარჯვენა შვილობილი წვერო მეტია მშობელზე.ეს პირობა ამარტივებს ძებნის ოპერაციას

---


![[Pasted image 20250411205420.png]]

---
![[Pasted image 20250411221137.png]]
