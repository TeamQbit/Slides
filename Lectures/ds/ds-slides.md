---
transition: none
width: "900"
timeForPresentation: "0"
---
მონაცემთა სტრუქტურები

note:
	მონაცემთა სტრუქტურები არის მონაცემთა ორგანიზების გზა რათა ის ეფექტურად იყოს შენახული გამოსაყენებლად. 

---

მასივები

![[Pasted image 20250316145434 (1).png]]

note:
ჩვენ უკვე ვიცით ერთი მონაცემთა სტრუქტურა.
დემეტრემ განიხილა მასივები,
როგორც უკვე ვასენეთ მასივი არის მონაცემთა სტრუქტურა რომელიც ინახავს ერთი ტიპის რამდენიმე მონაცემს,ერთ ცვლადში ნაცვლად ბევრი ცვლადისა,მაგრამ მასივს აქვს ერთი ნაკლი.მისი ზომის შეცვლა არ შეიძლება.ამ პრობლემის მოსაგვარებლად გვაქვს  დინამიური მასივი.

---

![[Pasted image 20250424184457.png]]

%%
```java
public class Main {
    public static void main(String[] args) {
        int[] arr = new int[5];
        arr[0] = 1;
        arr[1] = 2;
        arr[2] = 3;
        arr[3] = 4;
        arr[4] = 5;

        String[] arr1 = {"subscribe ", "to ", "Qbit"};
        for (int i = 0; i < arr1.length; i++) {
            System.out.print(arr1[i]);
        }
    }
}
// Output: subscribe to Qbit
```
%%

---

![[Pasted image 20250412211448.png|600]]

note:
მონაცემთა სტრუქტურის ანალოგია ბიბლიოთეკა, ცვენ შეგვიძლი მისი თაროებზე დაწყობა (ორგანიზება) მაგრამ

---

![[Pasted image 20250424184018.png]]

notes:
ანბანის მიხედვით რო დავალაგოთ, ესეც ორგანიზების სახეა, რომელიც მაგალითად წიგნის მოძებნას გაგვიმარტივებს სახელის მიხედვით.

---

დინამიური მასივი (Dynamic Array)

note:
დავუბრუნდეთ მასივებს, მასივს აქვს ერთი პრობლემა, მას აქვს ფიქსირებული ზომა, და თუ დაგვჭირდება მეტი ელემენტის ჩამატება, იძულებული ვართ შევქმნათ ახალი მასივი და გადავალაგოთ ძველი ელემენტები შიგნით + ახალი ელემენტი

---

![[Pasted image 20250424185459.png]]

note:
გვაქვს ოთხი ელემენტი, თუ გვინდა...

---

![[Pasted image 20250424185707.png]]

---

![[Pasted image 20250424185723.png]]

---

![[Pasted image 20250424185755.png]]

---

დინამიური მასივი

note:
ხოლო დინამიური მასივი ამას თავისით აკეთებს, ანუ მას რეალურად შიგნიდან აქვს უბრალო მასივი, ხოლო როცა მიაღწევს სრულ ზომას (მაგ 5დან 5 ელემენტი დაკავებულია), მაშინ იგი შექმნის უფრო დიდ მასივს გადაალაგებს ძველ ელემენტებს და ძველ პატარა მასივს წაშლის. ანუ აკეთებს ზომის ამორტიზაციას.

---

![[Pasted image 20250424193202.png]]

---

![[Pasted image 20250424193209.png]]

---

![[Pasted image 20250424193221.png]]

---

![[Pasted image 20250424193230.png]]

---


![[Pasted image 20250424192909.png]]

---

$$
new = \lfloor old \times 1.5 \rfloor
$$

![[Pasted image 20250424193309.png]]

note:
მართალია ჩვენ გვიწევს ცარიელი ადგილის შექმნა, რომელიც შეიძლება არც კი დაგვჭირდეს რომ შევავსოთ, თუმცა დინამიური მასივი საშუალებას გვაძლევს ეფექტურად გამოვიყენოთ მასივები თუ ხშირად გვიწევს დამატებითი ჩამატება/ამოკლება. ზომის ამორტიზებული ზრდა კი ნაკლებ რესურს ხარჯავს მასივის გასაზრდელად და ძველი ელემენტების გადასალაგებლად. ამიტომ ფიქსირებული სიგრძის სცენარში, ისევ კლასიკური მასივი ჯობია განსაზღვრული ზომით

---

ბმული სია (Linked List)

note:
	ბმული სია არის მონაცემთა მიმდევრობითი სტრუქტურა, რომელიც არ არის შეზღუდული ზომაში.

---

![[Pasted image 20250424195125.png]]

note:
მისი ყოველი ელემენტი ინახავს ორი ტიპის ინფორმაციას: ამ ელემენტის (Node) მნიშვნელობას და მომდევნო ელემენტის მისამართს (Reference)

---

ცალმხრივ მიმართული ბმული სია (Singly-Linked List)

![[Pasted image 20250424195202.png]]

note:
	არსებობს 2 ტიპის ბმულის სია
	1) ცალმხირვ მიმართული ბმული სიები - მხოლოდ მომდევნო ელემენტის მისამართზე და საკუთარ მნიშვნელობაზე აქვს ინფორმაცია
	
---

ორმხრივ მიმართული ბმული სია (Doubly-Linked List)

![[Pasted image 20250424195259.png]]

note:
	2) ორ მხრივ მიმართული ბმული სიები - აქვს ინფორმაცია საკუთარ მნიშვნელობაზე, მომდევნო და წინა ელემენტის მისამართზე. ანუ კონკრეტული ელემენტიდან შეგვიძლია შემდეგზე და წინაზე მოძრაობა ცალმხრივი სიისგან განსხვავებით

---

რუკა (Map) | ლექსიკონი (Dictionary)

---

![[Pasted image 20250424201003.png]]

note:
გეთანხმებით, ორი სათაური რა საჭიროა, თუმცა ორივე სახელით ვიცნობთ ამ სტრუქტურას თეორიასა და პროგრამირების ენებში

---

რუკა (Map) | ლექსიკონი (Dictionary)


![[Pasted image 20250425004708.png]]

note:
	მეფი არის მონაცემთა სტრუქტურა რომელიც ინახავს უნიკალურ გასაღებს (key) და მნიშვნელობა (value) წყვილებს. ეს ნიშნავს რომ ყოველი მნიშვნელობა დაკავშირებულია რაღაც ტიპის უნიკალურ გასაღებთან.
	მაგალითად:
	წარმოიდგინეთ ტელეფონის წიგნი სადაც სახელები არის გასაღებები (Keys) ტელეფონის ნომრები არის მნიშვნელობები (Values).
---

![[Pasted image 20250425004922.png]]

note:
 ან პიროვნებათა სია სადაც პირადი ნომერი უნიკალურია, თითოეული პირადი ნომერი კი შეესაბამება პირის სახელს და გვარს.
 
---

![[Pasted image 20250425005325.png]]

note:
 თუკი კონკრეტული გასაღებით დავამატებთ მნიშნელობას, ამ გასაღების შესაბამისი მნიშვნელობა ჩანაცვლდება ახლით.

---

![[Pasted image 20250425005419.png]]

---

![[Pasted image 20250425005540.png]]

---

![[Pasted image 20250425005639.png]]
note:
ხოლო თუ გასაღები ჯერ არ არსებობს, გასაღები დაემატება და შეესაბამება მას მნიშნელობა. გასაღების არსებობის შესამოწმებლად არ გვიწევს გადაყოლა და შემოწმება როგორც მასივზე, ეს ყველაფერი ჩქარდება Hashing/ჰეშირების და სხვა ოპტიმიზაციების ხარჯზე რომელსაც სხვა დროს განვიხილავთ.

---

 სიმრავლე (Set)

$N = \{1,2,3....100,300\}$
$S = \{მათე, რეზი, დემეტრე, \ldots, ქუბიტი\}$

note:
	 როგორც მათემატიკიდან ვიცით სიმრავლე არის რამდენიმე ელემენტის ერთობა,ოღონდ იმ პირობით რომ თითოეული ელემენტი მხოლოდ ერთხელ გვხვდება მოცემულ სიმრავლეში (უნიკალურია),განსხვავებით მასივისგან სიმრავლე დაუნომრავი მონაცემთა სტრუქტურაა შესაბამიდად მას არ გააჩნია ინდექსები
	 

---

![[Pasted image 20250412213911.png]]

note:
სიმრავლეები მასივისგან ან სიისგან განსხვავებით ეფექტურია როცა გვჭირდება შევამოწმოთ ელემენტის არსებობა სტრუქტურაში, ან ვიპოვოთ ორი სიმრავლის თანაკვეთა, გაერთიანება და ა.შ. რაც წინა სტრუქტურებში (მასივი, სია) მეტ რესურსს მოითხოვდა.

---

![[Pasted image 20250424201431.png]]

---

![[Pasted image 20250424201451.png]]

---

![[Pasted image 20250424201530.png]]

---

![[Pasted image 20250424201552.png]]

---

სტეკი (Stack)
note:
	სტეკი არის მონაცემთა სტრუქტურა რომელიც მიყვება ბოლო შესული - პირველი გამოსული (Last In, First Out (LIFO)) პრინციპს, რაც იმას ნიშნავს რომ ბოლო ელემენტი რომელიც დაემატება სტეკში პირველი იქნება რომელიც ამოღებადი იქნება.
	
---

![[Pasted image 20250425011812.png]]

---

![[Pasted image 20250425012017.png]]

note:
მაგალიღად:
წარმოიდგნეთ გვაქვს ერთმანეთზე დაწყობილი თეფშები (Stack of Dishes). ჩვენ ახალი თეფში თავზეო უნდა დავადოთ ამ თეფშების სტეკს და არ შეგვიძლია პირველად თეფში ავიღოთ მანამ, სანამ ყველა მის შემდეგ დამატებულ ღეფშს არ ავიღებთ.

---

![[Pasted image 20250425012331.png]]

note:
სტეკზე გვაქვს სულ რაღაც ორი ოპერაცია: Push და

---

![[Pasted image 20250425012452.png]]

note:
 Pop. მისი გაკეთება შეიძლება მასივის ან linked list საშუალებით, რასაც დავალებაში ჩვენით ავაწყობთ.

---

რიგი (Queue)

![[Pasted image 20250425012900.png]]

note:
	რიგი არის მონაცემთა სტრუქტურა პრომელიც მიყვება პირველი შევიდა პირველი გამოვიდა (First In, First Out (FIFO)) პრინციპს,რაც იმას ნიშნავს რომ პირველი ელემენტი რომელიც დაემატა იქნება პირველი რომელიც იქნება ხელმისაწვდომი, 

---

![[Pasted image 20250411212803.png]]

note:
როგორც ცოცხალი რიგის შემთხვევაში. იმას უფრო ადრე მოუწევს რიგი ვინც უფრო ადრე მივიდა.

---

![[Pasted image 20250425013214.png]]

note:
ქიუზე სტეკის მსგავსად გვაქვს ორი ოპერაცია. Enqueue 

---
![[Pasted image 20250425013413.png]]

note:
და Dequeue (რიგში შეტანა, რიგიდან გამოტანა).

---

გრაფი (Graph)

![[Pasted image 20250425014711.png]]

note:
	გრაფი არის მონაცემთა სტრუქტურა რომელიც შედგება წვეროების (Vertex), წიბო (Edge) კავშირებისგან. გრაფები გამოიყენება კავშირების ან ურთიერთობების წარმოსადგენად ობიექტებს შორის. არსებობს რამდენიმე ტიპის გრაფი
	1)მიუმართავი გრაფი (Undirected Graph) – მიუმართავ გრაფში წიბოებს (Edges) არ აქვთ მიმართულება, რაც ნიშნავს, რომ კავშირი ზოგადია (A და B არიან კავშირში).

---

მიუმართავი გრაფი (Undirected Graph)

![[Pasted image 20250425015116.png]]

note:
მაგალითად Facebook ზე როცა გვყავს მეგობარი (კავშირის სახე), ეს თავისთავად მისთვისაც ნიშნავს რომ ჩვენი მეგობარია. ამიტომ ურთიერთობას თუ გრაფით ავსახავთ, არ აქვს მიმართულებას მნიშვნელობა.

---

Directed Graph (მიმართული გრაფი)

![[Pasted image 20250425015622.png]]

note:
ზოგჯერ კავშირით ურთიერთობის გამოსახვასთან ერთად, გვჭირდება მიმართულების გამოსახვაც. მაგალითად, თუ ადამიანს Instagram ზე გამოვიწერთ (დავაფოლოვებთ) დავკავშირდებით ცალმხრივად მიმართული წიბოთი, რადგან ეს არ ნიშნავს რომ მასაც გვყავართ აუცილებლად გამოწერილი, ხოლო თუ ორივე მხარე იწერს (აფოლოვებს) ერთმანეთს ორმხრივი (bidirectional) წიბო დაკავშირდება მათ შორის.

---

აწონილი გრაფი (Weighted Graph)

![[Pasted image 20250425020033.png]]

 note:
 აწონილი გრაფი, მაგალითად ავიღოთ ქალაქები როგორც წვეროები და მათ შორის საგზაო კავშირი ავღნიშნოთ წიბოებით. იმის გამოსასახად თუ რა მანძილია A-B ქალაქს შორის წიბოს მივანიჭოთ წონა. ამ შემთხვევაში ეს წონა იყო მანძილი კილომეტრებში. მაგალთად თუ ბათუმიდან ქუთაისში მივდივარ შემიძლია ფოთის გავლით წავიდე ან პირდაპირ. ფოთის გავლით გზის წონების ჯამი უფრო მეტია ვიდრე ბათუმი-ქუთაისის წიბოს წონა. ამიტომ უმოკლესი მანძილი 148 იქნება. მსგავს და კიდევ ბევრად საინტერესო ალგორითმებს გრაფებზე და სხვა სტრუქტურებზე შემდეგ ლექციაში ნიკა განიხილავს.
 
---

ხე (Tree)

![[Pasted image 20250425021232.png]]

note:
	ხე არის მონაცემთა სტრუქტურა, რომელიც წარმოადგენს გრაფის სახეობას.
	გრაფებისგან განსხვავებით, ხეებს აქვთ გარკვეული წესები:
	- არ არის ციკლი.
	- გვაქვს N წვერო და N - 1 წიბო
	- 2 წვეროს შორის არსებობს უნიკალური გზა (Path)
- ხეს აქვს ერთი საწყისი წვერო (Root Node).
- თითოეულ წვეროს (გარდა ფესვისა) ყავს მხოლოდ ერთი მშობელი (Parent Node).
- წვეროებს რომელთაც შვილი არ ყავთ ქვიათ ფოთლები (Leaves)

---

![[Pasted image 20250411221137.png]]

---

ორობითი ხე (Binary Tree)

![[Pasted image 20250425021700.png]]

---

ორობითი ძებნის ხე (Binary Search Tree)

![[Pasted image 20250425021808.png]]

---

Java Collections Framework

![[Pasted image 20250425113247.png]]


%%
# ქოლექშენები უნდა ახსნა დემესავით კოდში ლეპტოპში

Collection & Map Interface

List, Queue, Set Interfaces
- ArrayList
- LinkedList
- Stack as LinkedList
- Queue as LinkedList
- HashSet

Map Interface
- HashMap

---

```java
import java.util.List;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>();
		List<String> words = new ArrayList<>(5);
    }
}
```

კლასი LinkedList

```java
import java.util.List;
import java.util.LinkedList;  
  
public class Main {  
    public static void main(String[] args) {  
        List<Integer> numbers = new LinkedList<>();  
        numbers.add(5);  
        numbers.add(3);  
    }  
}
```

note:
ჯავა თავის ბიბლიოთეკაში გვთავაზობს LinkedList კლასს რომელიც შინაგანად არის ორმხრივ მიმართული ბმული სია.

და ახსნი ამათ და ქოლექშენების იერარქიას.
%%

---

ასიმპტოტური ანალიზი

TODO